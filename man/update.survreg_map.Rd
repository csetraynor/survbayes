% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/survreg_map.R
\name{update.survreg_map}
\alias{update.survreg_map}
\title{Update method for \code{survreg_map}}
\usage{
\method{update}{survreg_map}(object, formula. = NULL, anc. = NULL,
  reeval_scaling_and_terms = NULL, ..., evaluate = TRUE)
}
\arguments{
\item{object}{Object of class \code{survreg_map}}

\item{formula.}{Passed to \code{update.formula} for the main formula argument.}

\item{anc.}{A named list of formulas, each of which are passed to \code{update.formula} for the
corresponding anc formula.}

\item{reeval_scaling_and_terms}{Should scaling and terms be re-computed with new data? For
details on scaling see 'Description'. This also controls whether the 'contrasts' and 'xlevels'
arguments are updated. Broadly, the idea is to be cross-validation friendly: for example, if
new factor-levels are present in a validation-fold that weren't in the training fold, that's OK
because all levels of the factor were remembered from the original model-object.}

\item{...}{Slots to update.}

\item{evaluate}{If true evaluate the new call else return the call.}
}
\value{
If evaluate = TRUE the fitted object, otherwise the updated call.
}
\description{
A critical difference between this update method and the typical method for other R objects
concerns how centering/scaling of the data is (not) updated. The standardization of variables is
important in \code{survreg_map}, because priors are placed on the standardized scale. So if
updating the data meant re-computing this standardization, the updated vs. original models would
effectively have different priors. Instead, for this update method, whether the standardization
is recomputed is controlled by the `reeval_scaling_and_terms` argument. If only data are being
updated, this defaults to FALSE, meaning that standardization will *not* be recomputed. This
includes both scaling accomplished by code within \code{survreg_map} (controlled by the
\code{standardize_x} argument), as well as scaling accomplished by transformations in the
formula, such as \code{stats::scale}, \code{stats::poly}, \code{splines::ns}, and other functions
with \code{makepredictcall} methods (this is controlled by the \code{predvars} argument).
}
