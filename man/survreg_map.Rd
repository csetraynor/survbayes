% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/survreg_map.R
\name{survreg_map}
\alias{survreg_map}
\title{Survival Regression with MAP}
\usage{
survreg_map(formula, anc = NULL, data, distribution = "roy_parm_splines",
  dist_config = list(knots = NULL), na.action = na.exclude, priors = NULL,
  standardize_x = TRUE, contrasts = NULL, xlevels = NULL,
  optim_args = list(method = "BFGS", control = list(trace =
  as.integer(interactive()), maxit = 250)), predvars = NULL)
}
\arguments{
\item{formula}{Formula, with both rhs and lhs, for the main parameter of the distribution.}

\item{anc}{A list of formulae, rhs only, named for other parameters of the distribution.}

\item{data}{A data.frame}

\item{distribution}{Character-string for distribution.}

\item{dist_config}{A list with options controlling the distribution.}

\item{na.action}{Function for NAs}

\item{priors}{Either object resulting from \code{set_prior} (or a list of these), or a data.frame
with columns 'parameter', 'term', 'family', 'location', 'spread'. An optional logical column
'fixed' can be used to specify parameters that should be fixed at their initial value and not
updated during optimization. Note that priors are placed on the predictors *after* these
predictors are centered and scaled, according to the \code{standardize_x} argument.}

\item{standardize_x}{Either a logical specifying whether to center/scale numeric predictors, or a
list with names 'center' and 'scale', each of which in turn are named numeric vectors
specifying centering/scaling. Because priors are placed on the standardized scale, this is an
important argument; see Details.}

\item{contrasts}{Contrasts that will determine how factors are formatted. Often the user doesn't
want to use this argument, but instead it's useful for `update`. See 'Details' and
\code{?update.survreg_map}.}

\item{xlevels}{The levels for each factor (for when contrasts are not explicit). See
\code{?update.survreg_map}.}

\item{optim_args}{Arguments to pass to \code{stats::optim}}

\item{predvars}{The 'predvars' attribute of a terms object. See \code{?update.survreg_map}.}
}
\value{
An object of type \code{survreg_map}
}
\description{
Fits a survival-regression model with MAP (Maximum a posteriori estimation).
}
\details{
This function centers and scales all numeric predictors before the fitting process, and all
priors are placed on this standardized scaled. There are some advantages to this. First,
default-priors are meaningful and applicable for all numeric predictors: they can be interpreted
as mean/expectation at no effect of each predictor, with a standard-deviation on this prior equal
to the standard-deviation for that predictor. (For factors, you can set the contrasts to
\code{contr.full} to acheive a similar effect.) Second, it's easy to set a single value for the
'spread' of the prior on all (non-intercept) predictors, which means it's easy to use priors for
their regularization properties -- e.g., trying different values for the 'spread' and picking the
one that maximizes cross-validation performance. See \code{crossv_loglik}.

The disadvantage to standardizing the predictors is that a little more care is needed in
preserving the standardization-parameters across model-calls. Default behavior for R's
\code{update} function would recompute these parameters on each call: in this case it would mean
refitting with new data (updating nothing else), which would have the side-effect of updating the prior
(since updating the data would change the mean and standard-deviation of your predictors). This
function avoids this unexpected behavior with the \code{standardize_x}, \code{predvars}, and
\code{contrasts} arguments.

The \code{standardize_x} argument, if set to TRUE, will center and scale all numeric predictors.
If a list specifying standardization-parameters is passed, then these will be used and not
recomputed. The \code{update} method for \code{survreg_map} is smart enough to take advantage of
this functionality: if only the data is being updated, it will make sure to replace the
\code{standardize_x=TRUE} from the original call with \code{standardize_x=[the parameters from
the first call]}.

Some R transformation-functions perform standardization for you: for example,
\code{stats::scale} or \code{stats::poly} (use \code{methods(makepredictcall)} to see them all).
This function handles these by saving the 'predvars' attribute after the parameters are first
computed. Just like \code{standardize_x}, the update method can then avoid re-computing these.

Finally, \code{contr.full} centers your contrast-codes based on the data it sees when first
calling this function; if you call \code{update}, these contrasts will be preserved with the
\code{contrasts} argument.
}
